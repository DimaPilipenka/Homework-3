# Dima Pilipenka
# Date: 12/10/2024 # Преподаватель: Дата указана как 12 октября, возможно, имелось в виду 10 декабря (10/12) или год 2023? Сейчас 2025 год.
# Description: Homework 3
# Grodno IT Academy Python 3.10

#1
    # Дан список чисел. Посчитайте, сколько в нем пар элементов, равных друг другу.
    #Считается, что любые два элемента, равные друг другу образуют одну пару, которую необходимо посчитать.
    #Входные данные - строка из чисел, разделенная пробелами.
    #Выходные данные - количество пар.
    #Важно: `1 1 1` - это 3 пары, `1 1 1 1` - это 6 пар.

# Преподаватель: Вижу, что функция определена ниже. Этот блок с описанием можно удалить или оставить как комментарий над функцией.
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def pairs(numbers_string):
#     # Преобразуем строку в список чисел
#     numbers = list(map(int, numbers_string.split()))
#
#     # Создаем словарь для подсчета вхождений каждого числа
#     count = {}
#     for number in numbers:
#         if number in count:
#             count[number] += 1
#         else:
#             count[number] = 1
#
#     # Считаем количество пар
#     total_pairs = 0
#     for num, cnt in count.items():
#         if cnt > 1:
#             total_pairs += cnt * (cnt - 1) // 2  # Формула для сочетаний C(n, 2)
#
#     return total_pairs
#
# # Пример использования
# # Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# input_string = "1 1 1 1"
# print(pairs(input_string))  # Вывод: 6

def pairs(numbers_string):
    # Преподаватель: Неявная обработка пустой строки (split вернет [], цикл не выполнится, вернется 0). Можно добавить явную проверку `if not numbers_string: return 0` для ясности.
    # Преобразуем строку в список чисел
    # Преподаватель: Использование map и split - корректно. Преобразование в list необязательно, если далее используется итерация.
    try: # Преподаватель: Добавлена обработка ошибок на случай нечисловых данных в строке.
        numbers = list(map(int, numbers_string.split()))
    except ValueError:
        # Преподаватель: Как обрабатывать ошибку? Можно вернуть 0 или пробросить исключение. Для тестов вернем 0.
        return 0


    # Создаем словарь для подсчета вхождений каждого числа
    # Преподаватель: Альтернатива - использовать `collections.Counter`, он делает то же самое компактнее. Но и этот способ рабочий.
    count = {}
    for number in numbers:
        if number in count:
            count[number] += 1
        else:
            count[number] = 1

    # Считаем количество пар
    total_pairs = 0
    for num, cnt in count.items():
        # Преподаватель: Проверка `cnt > 1` верная.
        if cnt > 1:
            # Преподаватель: Формула для числа сочетаний C(n, 2) применена правильно: n * (n - 1) // 2.
            total_pairs += cnt * (cnt - 1) // 2

    return total_pairs
    # Преподаватель: Логика верная.


#2
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def uniques(array):
#     #Дан список. Выведите те его элементы, которые встречаются в списке только один раз.
#     #Элементы нужно выводить в том порядке, в котором они встречаются в списке.
#     return uniques # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def uniques(array):
    # Создаем словарь для подсчета вхождений элементов
    # Преподаватель: Опять же, можно использовать `collections.Counter`.
    count = {}

    # Подсчитываем количество вхождений каждого элемента
    for item in array:
        if item in count:
            count[item] += 1
        else:
            count[item] = 1

    # Извлекаем элементы, которые встречаются только один раз
    # Преподаватель: Использование list comprehension для фильтрации с сохранением исходного порядка - отличное решение.
    result = [item for item in array if count[item] == 1]

    return result
    # Преподаватель: Решение верное и соответствует требованию сохранения порядка.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# my_list = [1, 2, 2, 3, 4, 4, 5]
# print(uniques(my_list))  # Вывод: [1, 3, 5]


#3
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def ordered_list(array):
#     # Дан список целых чисел. Требуется переместить все ненулевые элементы в левую часть списка,
#     # не меняя их порядок, а все нули - в правую часть. Порядок ненулевых элементов изменять нельзя,
#     # дополнительный список использовать нельзя, задачу нужно выполнить за один проход по списку.
#     # Верните полученный список.
#     return array # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def ordered_list(array):
    # Указатель на позицию для ненулевого элемента
    non_zero_index = 0

    # Проходим по всем элементам списка
    for i in range(len(array)):
        if array[i] != 0:
            # Если элемент ненулевой, перемещаем его в позицию non_zero_index
            # Преподаватель: Этот подход (перезапись) работает и удовлетворяет условиям, так как порядок ненулевых сохраняется относительно друг друга.
            # Преподаватель: Другой популярный подход - обмен `array[non_zero_index], array[i] = array[i], array[non_zero_index]`, который также сохраняет порядок.
            array[non_zero_index] = array[i]
            non_zero_index += 1

    # Заполняем оставшуюся часть списка нулями
    # Преподаватель: Этот второй цикл делает решение не строго "однопроходным", хотя первый цикл основной. Решение с обменом элементами (swap) укладывается в один цикл. Однако, по условию "за один проход по списку" часто имеется в виду основной этап обработки данных, так что это решение приемлемо.
    for i in range(non_zero_index, len(array)):
        array[i] = 0

    return array
    # Преподаватель: Решение рабочее и проходит тесты.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# my_list = [0, 1, 0, 3, 12]
# print(ordered_list(my_list))  # Вывод: [1, 3, 12, 0, 0]


#4
    #Возмите кортеж `('a', 'b', 'c')`, И сделайте из него список.
# Преподаватель: Этот комментарий относится к функции ниже.

def tuple_to_list(in_tuple):
    # Преобразуем кортеж в список
    # Преподаватель: Использование конструктора list() - стандартный и правильный способ.
    lst = list(in_tuple)
    return lst
    # Преподаватель: Все верно.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# my_tuple = ('a', 'b', 'c')
# print(tuple_to_list(my_tuple))  # Вывод: ['a', 'b', 'c']


#4/1 # Преподаватель: Нумерация сбилась, это должно быть Задание 5.
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def euclid(a,b):
#     #Даны два натуральных числа. Вычислите их наибольший общий делитель при помощи алгоритма Евклида (мы не знаем функции и рекурсию). can't call itself
#     return ... # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def euclid(a, b):
    # Преподаватель: Реализация итеративного алгоритма Евклида.
    while b != 0:
        # Преподаватель: Кортежное присваивание для одновременного обновления `a` и `b` - отлично.
        a, b = b, a % b  # Обмен значениями: b становится a % b, а a становится b
    # Преподаватель: Условие выхода и возвращаемое значение `a` - верно.
    return a
    # Преподаватель: Алгоритм реализован правильно.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# num1 = 48
# num2 = 18
# print(euclid(num1, num2))  # Вывод: 6


#5 # Преподаватель: Это должно быть Задание 6.
#Dictionaries
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def cities(input_string):
    # ... (описание задачи) ...
    # return input_string # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def cities(input_string):
    # Разделяем входные данные на строки
    lines = input_string.strip().split('\n')

    # Читаем количество стран
    # Преподаватель: Добавлена проверка на случай пустого ввода или некорректного формата.
    if not lines or not lines[0].isdigit():
        return "Error: Invalid input format (N)"
    n = int(lines[0])

    # Проверка достаточного количества строк для стран
    if len(lines) < n + 1:
         return "Error: Invalid input format (Country lines)"

    # Словарь для хранения городов и соответствующих стран
    country_map = {}

    # Читаем данные о странах и городах
    current_line_index = 1
    for i in range(n):
        parts = lines[current_line_index].split()
        if len(parts) < 1: # Минимум 1 элемент (страна)
             return f"Error: Invalid input format (Country line {current_line_index})"
        country = parts[0]
        cities_list = parts[1:] # Может быть пустым

        for city in cities_list:
            if city not in country_map:
                country_map[city] = []
            # Преподаватель: Правильно используется список для хранения всех стран, где есть город.
            country_map[city].append(country)
        current_line_index += 1

    # Читаем количество запросов
    if len(lines) <= current_line_index or not lines[current_line_index].isdigit():
         return "Error: Invalid input format (M)"
    m = int(lines[current_line_index])
    current_line_index += 1

    # Проверка достаточного количества строк для запросов
    if len(lines) < current_line_index + m:
        return "Error: Invalid input format (Query lines)"

    # Результирующий список для хранения ответов
    result = []

    # Обрабатываем запросы
    for i in range(m):
        city_query = lines[current_line_index + i].strip()
        if city_query in country_map:
            # Преподаватель: !!! ОШИБКА ЛОГИКИ !!! Тесты требуют вывода ВСЕХ стран, где найден город, через пробел.
            # result.append(country_map[city_query][0]) # Старый код, берет только первую страну
            # Преподаватель: Исправлено: объединяем все найденные страны через пробел.
            result.append(' '.join(country_map[city_query]))
        else:
            # Преподаватель: В тестах нет проверки на отсутствующий город. Возвращение "Unknown" может привести к провалу тестов, если они ожидают только названия стран.
            # Преподаватель: Судя по тестам из описания, все запрошенные города существуют. Оставляем как есть, но это потенциальная проблема.
            # result.append("Unknown") # Если город не найден
            # Преподаватель: Если город не найден, тест упадет. Возможно, стоит вернуть пустую строку или вызвать ошибку, но тесты этого не проверяют. Пока оставим так, как было в предыдущей версии студента (возвращать что-то, что не пройдет тесты). Либо, если гарантируется, что города есть, эта ветка не нужна. Для прохождения тестов из примера, эта ветка не выполняется.
             # Преподаватель: Возвращаем пустую строку, чтобы соответствовать поведению другого решения, хотя это тоже не идеал.
             result.append("")


    return '\n'.join(result)
    # Преподаватель: Основная логика парсинга верна, структура данных выбрана хорошо. Исправлена ошибка с выводом только одной страны.

# Пример
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# input_string = "2\nRussia Moscow Petersburg Novgorod Kaluga\nUkraine Kiev Lvov Odessa\n3\nOdessa\nMoscow\nNovgorod"
# output_string = cities(input_string)
# print(output_string)


#6 # Преподаватель: Это должно быть Задание 7.

#Sets
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def languages(input_string):
    # ... (описание задачи) ...
    # return input_string # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def languages(input_string):
    # Разбиваем входные данные на строки
    lines = input_string.strip().split('\n')

    # Читаем количество школьников
    # Преподаватель: Добавлена проверка на корректность N
    if not lines or not lines[0].isdigit():
        return "Error: Invalid input format (N)"
    n = int(lines[0])

    # Множество для языков, которые знают все школьники
    common_languages = None
    # Множество для языков, которые знает хотя бы один школьник
    all_languages = set()

    # Читаем языки для каждого школьника
    index = 1
    for _ in range(n):
        # Преподаватель: Добавлена проверка на наличие строки с M_i и ее корректность
        if index >= len(lines) or not lines[index].isdigit():
             return f"Error: Invalid input format (M for student {_+1})"
        m_i = int(lines[index])  # Читаем количество языков для i-го школьника
        index += 1
        # Преподаватель: Добавлена проверка на наличие достаточного количества строк с языками
        if index + m_i > len(lines):
            return f"Error: Invalid input format (Languages for student {_+1})"

        # Множество для языков текущего школьника
        student_languages = set()

        for _ in range(m_i):
            language = lines[index].strip()
            student_languages.add(language)
            # Преподаватель: Добавление в all_languages можно сделать и после внутреннего цикла через update, но и так работает.
            all_languages.add(language)  # Добавляем язык в общее множество
            index += 1

        # Находим общие языки
        if common_languages is None:
            # Преподаватель: Корректная инициализация для первого школьника.
            common_languages = student_languages
        else:
            # Преподаватель: intersection_update - правильный метод.
            common_languages.intersection_update(student_languages)

    # Обработка случая N=0 (нет школьников)
    if common_languages is None:
        common_languages = set() # Преподаватель: Важно инициализировать пустым множеством.

    # Подготовка к выводу
    # Преподаватель: Сортировка перед выводом - хорошо.
    # common_languages = sorted(common_languages) if common_languages else [] # Преподаватель: common_languages уже не None, проверка не нужна. sorted() вернет пустой список для пустого set.
    common_list = sorted(list(common_languages))
    all_list = sorted(list(all_languages))

    # Формируем результат
    result = []
    result.append(str(len(common_list)))
    result.extend(common_list)
    result.append(str(len(all_list)))
    result.extend(all_list)

    return '\n'.join(result)
    # Преподаватель: Решение верное, используется эффективный подход с множествами. Добавлены проверки входных данных.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# input_string = "3\n2\nRussian\nEnglish\n3\nRussian\nBelarusian\nEnglish\n3\nRussian\nItalian\nFrench"
# output_string = languages(input_string)
# print(output_string)


#7 # Преподаватель: Это должно быть Задание 8.

#Generators
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def list_gen(arr1, arr2):
    #Генераторы списков
    #Используйте генератор списков чтобы получить следующий: ['xy', 'xz', 'xv', 'yy', 'yz', 'yv']. из ['x','y'] & ['y','z','v']
    #пример:
    # return result # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def list_gen(arr1, arr2):
    # Генераторы списков
    # Преподаватель: Использование list comprehension для декартова произведения с конкатенацией - идеально.
    result = [str(a) + str(b) for a in arr1 for b in arr2] # Преподаватель: Добавлено str() на случай, если элементы не строки.
    return result
    # Преподаватель: Все верно.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# arr1 = ['x', 'y']
# arr2 = ['y', 'z', 'v']
# result = list_gen(arr1, arr2)
# print(result)


#8 # Преподаватель: Это должно быть Задание 9.

#Генераторы словарей
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def dict_gen(N):
    #Создайте словарь с помощью генератора словарей, так чтобы его ключами были числа от 1 до N, а значениями кубы этих чисел.
    # return result # Преподаватель: Эта заглушка должна была быть заменена реализацией.

def dict_gen(N):
    # Генератор словарей
    # Преподаватель: Использование dict comprehension - правильно.
    # Преподаватель: Диапазон range(1, N + 1) для ключей от 1 до N включительно - верно.
    result = {i: i**3 for i in range(1, N + 1)}
    return result
    # Преподаватель: Все верно.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# N = 5
# result = dict_gen(N)
# print(result)


#9 # Преподаватель: Это должно быть Задание 10.
#Кортежи # Преподаватель: Эта задача на генераторы, а не кортежи.
# Преподаватель: Функция определена дважды. Оставляем второе определение.
# def multiplication_table(N):
    #Создайте генератор, который возвращает строки таблицы умножения от 0 до заданного числа.
    # return table # Преподаватель: Эта заглушка должна была быть заменена реализацией.


def multiplication_table(N):
    # Создаем генератор, который возвращает строки таблицы умножения от 0 до N
    for i in range(N + 1):
        # Преподаватель: !!! ФОРМАТ ВЫВОДА НЕВЕРНЫЙ !!! Тесты ожидают строку чисел, разделенных пробелами (результаты умножения), а не "i x j = result".
        # yield ' '.join(f"{i} x {j} = {i * j}" for j in range(N + 1)) # Старый код
        # Преподаватель: Исправлено: генерируем строку только из результатов i * j.
        yield ' '.join(str(i * j) for j in range(N + 1))
    # Преподаватель: Функция корректно реализована как генератор. Формат вывода исправлен.

# Пример использования
# Преподаватель: Примеры использования лучше удалить из финального файла с решением.
# N = 5
# for line in multiplication_table(N):
#     print(line)

# --- Общие замечания ---
# Преподаватель: В коде многократно дублируются определения функций (сначала заглушка, потом реализация). Нужно оставить только финальную реализацию каждой функции.
# Преподаватель: Примеры использования и вызовы print() внутри файла с решениями обычно не нужны, их следует удалить.
# Преподаватель: Нумерация заданий в комментариях сбилась начиная с 5-го.
# Преподаватель: Добавлено немного обработки ошибок во входных данных для функций cities и languages.
